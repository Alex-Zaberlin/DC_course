#datacamp course
#first section
#zadacha32

"""
Для начала решим вот такую задачу, которая является довольно популярным парадоксом.
На столе лежат два внешне неразличимых конверта. В одном из них лежит ровно в 
два раза больше денег, чем в другом. Можно выбрать любой из конвертов и 
увидеть, что в нём лежит x рублей. Есть возможность взять открытый конверт или 
отказаться от него и взять сумму в закрытом конверте.
"""

##Тестовый вопрос
#До того, как мы перейдём к непосредственно коду, ответим на несколько тестовых вопросов:
#Выберете правильную запись решения следующей задачи:
#Артём получил по математике за четверть 8 оценок: 5, 5, 3, 5, 5, 5, 4.
#Будет ли у Артёма 5 в четверти? Выводом должна быть оценка Артёма за четверть.
'''
a) import numpy
marks = [5, 5, 3, 5, 5, 5, 4]
mean_value = np.mean(marks)
print(int(mean_value))
b) import numpy as np
marks = [5, 5, 3, 5, 5, 5, 4]
mean_value = np.mean(marks)
print(round(mean_value))
c) import numpy as np
marks = [5, 5, 3, 5, 5, 5, 4]
mean_value = mean(marks)
print(floor(mean_value))
d) import numpy as np
marks = [5, 5, 3, 5, 5, 5, 4]
mean_value = np.mean(marks)
print(mean_value)
'''

#Эту задачу можно решить двумя способами. Для начала решим грубой силой.
#Чему равно математическое ожидание суммы денег, лежащей в закрытом конверте?
import random as rd #Импортируем библиотеку, которая отвечает за случайность
x = rd.randint(0, 100) #Задаём некое случайное значение x, так как оно не влияет на ответ задачи
p1 = 1/2 #Вероятность того, что открывается первый конверт
p2 = p1 #Вероятность того, что открывается второй конверт равна вероятности, что открывается первый конверт
w1 = 2 * x #Наибольший выигрыш, который лежит в первом или втором конверте
w2 = 1/2 * x #Наименьший выигрыш, который лежит в первом или втором конверте
math_waiting = p1 * w1 + p2 * w2 #Формула по которой можно высчитать математическое ожидание
print(x, math_waiting) #Вывод нашего случайного значения и математического ожидание модели в зависимости от этого числа

#Настал черед более элегантного решения, которое позволяет применить навыки. полученные в предыдущих задачах.
#Чему равно математическое ожидание суммы денег, лежащей в закрытом конверте?
def math_waiting_a(list_of_args): #создаем функцию
    m_w = 0 #Вводим переменную отвечающую за матожидание
    n = len(list_of_args) # Считаем количество событий в нашем списке, так ка к они равновероятны
    for i in range(n): #Для каждого события выполняем цикл
        m_w += 1 / n * list_of_args[i] #Добавляем пособытийно в матожидание произведения вероятностей событий на события
    return(m_w) #Возращаем результат нашей функции


import random as rd #Импортируем библиотеку, которая отвечает за случайность
x = rd.randint(0, 100) #Задаём некое случайное значение x, так как оно не влияет на ответ задачи
list_of_args = [1/2 * x, 2 * x] #Создаем список возможных выигрышей
print(x, math_waiting_a(list_of_args)) ##Вывод нашего случайного значения и математического ожидание модели в зависимости от этого числа
#Стоит заметить, что если изменить количество событий, то всё равно будет получен верный ответ для указанного количества событий

##Тестовый вопрос
#Какой конверт стоит предпочесть, уже открытый или еще закрытый?
'''
a) Открытый конверт
b) Закрытый конверт
c) Любой, так как равновероятны события получения большей суммы и меньшей суммы
'''

##Тестовый вопрос
''' 
А если немного изменить условия лотереи и положить перед испытуемым 3 конверта 
с выигрышами N, 2N и 4N. Далее, открывается один из лежащих на столе и игрока спрашивают, 
хочет ли он поменять конверт. Если да, то случайным образом выбирается один из двух оставшихся.
Выгодно ли меняться?

а) Да, так как математическое ожидание выигрыша от второго конверта больше, чем результат открытого первого
б) Все равно, так как математические ожидания совпадают
в) Нет, так как математическое ожидание выигрыша от второго конверта меньше, чем результат открытого первого
'''

##Тестовый вопрос
'''
Еще немного поэкспериментируем. Перед началом эксперимента нам разрешат выбрать количество раз,
во сколько выигрыш в "хорошем" конверте будет отличаться от выигрыша в "плохом" конверте. 
Как тогда нам выгоднее поступить?

а) выбрать конверты с одинаковыми выигрышами, то есть установить коэффециент отличия k = 1
б) нет разницы, какой коэффициент выбирать
в) чем больше коэффициент отличия, тем сильнее наше преимущество в игре
г) чем меньше коэффициент отличия, тем сильнее наше преимущество в игре

'''


"""
Предположим, что деньги в конверты кладут следующим образом: в один из 
конвертов кладут случайную сумму денег, имеющую экспоненциальное 
распределение с параметром λ = 1, а в другой конверт — в два раза больше. 
Как выглядит оптимальная стратегия игрока?
"""

#Для начала воспользуемся функцией, которую создали в предудущем пункте
def math_waiting_b(list_of_args): #создаем функцию
    m_w = 0 #Вводим переменную отвечающую за матожидание
    n = len(list_of_args) # Считаем количество событий в нашем списке, так как они равновероятны
    for i in range(n): #Для каждого события выполняем цикл
        m_w += 1 / n * list_of_args[i] #Добавляем пособытийно в матожидание произведения вероятностей событий на события
    return(m_w) #Возращаем результат нашей функции


import numpy as np # Импортируем библиотеку, которая отвечает за математические функции и работу с ними
import random as rd #Импортируем библиотеку, которая отвечает за случайность
i = 0 #Счетчик количества раз работы цикла
res = 0 #Счетчик количества успехов
sum_1 = 0 #Счетчик суммы денег, если никогда не меняем конверты
sum_2 = 0 #Счетчик суммы денег, если всегда меняем конверты
while i < 10000: #Выполняем цикл, пока счетчик меньше заданного значения
    envelope_1 = np.random.exponential(scale=1, size = (1, 1)) #задаем сумму денег в первом или втором конверте
    envelope_2 = 3 * envelope_1 #задаем сумму денег во оставшемся конверте
    first_solution = rd.choice([envelope_1, envelope_2]) #Открываем случайным образом один из конвертов
    list_of_args = [1/3 * first_solution, 3 * first_solution] #Задаём список возможных выигрышей
    if first_solution == envelope_1: #Если выбрали первый конверт
        final_solution = envelope_2 # То выбираем в итоге другой конверт
    else: #Если выбрали второй конверт
        final_solution = envelope_1 #То выбираем в итоге другой конверт
    i += 1 #Прибавляем прохождение цикла
    if first_solution == envelope_1: #Проверяем, что открыли конверт с меньшей суммой денег
        res += 1 #Добавляем эту попытку в качестве успешной
    else: #Понимаем, что выбрали неправильный конверт
        res += 0 #Не считаем эту попытку успешной
    sum_1 += first_solution #Добавляем случаи, в которых никогда не меняем конверты
    sum_2 += final_solution #Добавляем случаи, в которых всегда меняем конверты
print(res/i) #Выводим среднюю успешность выбора другого конверта
print(sum_1, sum_2) #Сравниваем суммы денег при двух стратегиях

"""
Предположим, что деньги в конверты кладут другим образом. Сначала подбрасывают 
правильную монетку до тех пор, пока не выпадет «орёл». Обозначим количество 
подбрасываний буквой N. В один из конвертов кладут 3N рублей, а в другой конверт — 9N. 
Как выглядит оптимальная стратегия игрока?
"""

## Тестовый вопрос
'''
Меняется ли условии игры по сравнению с экспериментом, когда случайно выбирают выигрышы, при
условии, что один из них должен в 3 раза превосходить другой?

а) Нет, ничего не меняется
б) Поменялось бы ТОЛЬКО в случае, если бы монетка была не симметричной
в) Да, меняется, так как вероятность, что орёл первый раз выпадет на n-ом шаге меньше, чем вероятность, что 
орел в первый раз выпадет на (n-1)-ом шаге
'''

## Тестовый вопрос
'''
Выберите правильное утверждение относительно идеи стратегии, которую нужно простроить:

а) страгетия будет одинаковая при любом выигрыше, оказавшемся в первом открытом конверте
б) нам всегда выгодно поменяться, если мы получили в результате открытия первого конверта
выигрыш, кратный 3, но не кратный 9
в) если мы открыли число и оно оказалось кратно 9, то чем оно больше, тем больше 
математическое ожидание выигрыша во втором
'''
#Для начала создадим функцию, которая возращает нам количество подбрасываний монетки
def orresh(): #Создаем функцию
    N = 1 #Делаем первое подбрасывание
    k = rd.randint(0, 1) #Подбрасываем монетку
    while k != 1: #Продолжаем подбрасывать монетку, пока не выпадет 1 - "орел"
        k = rd.randint(0, 1) #Подбрасывание монетки
        N += 1 #Увеличение количества подбрасываний
    return(N) #Возращаем количество подбрасываниий, которое потребовалось для получения орла

#Затем воспользуемся функцией, которую создали в предудущем пункте
def math_waiting_c(list_of_args): #создаем функцию
    m_w = 0 #Вводим переменную отвечающую за матожидание
    n = len(list_of_args) # Считаем количество событий в нашем списке, так как они равновероятны
    for i in range(n): #Для каждого события выполняем цикл
        m_w += 1 / n * list_of_args[i] #Добавляем пособытийно в матожидание произведения вероятностей событий на события
    return(m_w) #Возращаем результат нашей функции


import numpy as np # Импортируем библиотеку, которая отвечает за математические функции и работу с ними
import random as rd #Импортируем библиотеку, которая отвечает за случайность
i = 0 #Счетчик количества раз работы цикла
res = 0 #Счетчик количества успехов
while i < 10000: #Выполняем цикл, пока счетчик меньше заданного значения
    envelope_1 = 3 * orresh() #задаем сумму денег в первом или втором конверте
    envelope_2 = 3 * envelope_1 #задаем сумму денег во оставшемся конверте
    first_solution = rd.choice([envelope_1, envelope_2]) #Открываем случайным образом один из конвертов
    list_of_args = [1/3 * first_solution, 3 * first_solution] #Задаём список возможных выигрышей
    if first_solution == envelope_1: #Если выбрали первый конверт
        final_solution = envelope_2 # То выбираем в итоге другой конверт
    else: #Если выбрали второй конверт
        final_solution = envelope_1 #То выбираем в итоге другой конверт
    i += 1 #Прибавляем прохождение цикла
    if first_solution == envelope_1: #Проверяем, что открыли конверт с меньшей суммой денег
        res += 1 #Добавляем эту попытку в качестве успешной
    else: #Понимаем, что выбрали неправильный конверт
        res += 0 #Не считаем эту попытку успешной
    sum_1 += first_solution #Добавляем случаи, в которых никогда не меняем конверты
    sum_2 += final_solution #Добавляем случаи, в которых всегда меняем конверты
print(res/i) ##Выводим среднюю успешность выбора другого конверта
print(sum_1, sum_2) #Сравниваем суммы денег при двух стратегиях
